/*{
  "DESCRIPTION": "Wild Pixel Sort",
  "CREDIT": "Your Name",
  "ISFVSN": "2",
  "CATEGORIES": ["Glitch", "Stylize"],
  "INPUTS": [
    {
      "NAME": "inputImage",
      "TYPE": "image"
    },
    {
      "NAME": "feedbackImage",
      "TYPE": "image"
    },
    {
      "NAME": "Wildness",
      "TYPE": "float",
      "MIN": 0.0,
      "MAX": 5.0,
      "DEFAULT": 0.0
    },
    {
      "NAME": "Threshold",
      "TYPE": "float",
      "MIN": 0.0,
      "MAX": 1.0,
      "DEFAULT": 0.5
    },
    {
      "NAME": "On",
      "TYPE": "bool",
      "DEFAULT": true
    },
    {
      "NAME": "Vertical",
      "TYPE": "bool",
      "DEFAULT": false
    },
    {
      "NAME": "Reverse",
      "TYPE": "bool",
      "DEFAULT": false
    }
  ],
    "PASSES": [
    {
      "TARGET": "OldTexture",
      "PERSISTENT": true
    }
  ]
}*/

// grayscale average of the colors
float gscale (vec3 c) { return (c.r+c.g+c.b)/3.; }

void main()
{
  vec2 st = isf_FragNormCoord;

  if (!On || Wildness < 1.) {
    gl_FragColor = IMG_NORM_PIXEL(inputImage, st);
    return;
  }

  // the frame number parity, -1 is odd 1 is even
  float fParity = mod(float(FRAMEINDEX), 2.) * 2. - 1.;

  if (Vertical) {
    // we differentiate every 1/2 pixel on the vertical axis, will be -1 or 1
    float vp = mod(floor(isf_FragNormCoord.y * RENDERSIZE.y), 2.0) * 2. - 1.;

    vec2 dir = vec2(0, 1);
    if (Reverse) dir *= -1.0;
    dir*= fParity * vp;
    dir/= RENDERSIZE.xy;

    // we sort
    vec4 curr = IMG_NORM_PIXEL(feedbackImage, st);

    float gCurr = gscale(curr.rgb);

    // skip transparent pixels
    if (curr.a < 0.01) {
      gl_FragColor = curr;
      return;
    }

    // we prevent the sort from happening on the borders
    if (st.y + dir.y < 0.0 || st.y + dir.y > 1.0) {
      gl_FragColor = curr;
      return;
    }

    vec4 comp;
    float gComp;

    int loopStart = Reverse ? 1 : int(floor(Wildness));
    int loopEnd = Reverse ? int(floor(Wildness)) : 0;
    int loopStep = Reverse ? 1 : -1;

    for (int i = loopStart; Reverse ? (i <= loopEnd) : (i > loopEnd); i += loopStep) {
      comp = IMG_NORM_PIXEL(feedbackImage, st + i * dir);
      gComp = gscale(comp.rgb);
      if (dir.y < 0.0) {
        if (gCurr > Threshold && comp.a > 0.01 && (Reverse ? gComp < gCurr : gComp > gCurr)) {
          gl_FragColor = comp;
          return;
        }
      } else {
        if (gComp > Threshold && comp.a > 0.01 && (Reverse ? gCurr <= gComp : gCurr >= gComp)) {
          gl_FragColor = comp;
          return;
        }
      }
    }
    gl_FragColor = curr;
  } else {

    // we differentiate every 1/2 pixel on the horizontal axis, will be -1 or 1
    float vp = mod(floor(isf_FragNormCoord.x * RENDERSIZE.x), 2.0) * 2. - 1.;

    vec2 dir = vec2(1, 0);
    if (Reverse) dir *= -1.0;
    dir*= fParity * vp;
    dir/= RENDERSIZE.xy;

    // we sort
    vec4 curr = IMG_NORM_PIXEL(feedbackImage, st);
    float gCurr = gscale(curr.rgb);

    // skip transparent pixels
    if (curr.a < 0.01) {
      gl_FragColor = curr;
      return;
    }

    // we prevent the sort from happening on the borders
    if (st.x + dir.x < 0.0 || st.x + dir.x > 1.0) {
      gl_FragColor = curr;
      return;
    }

    vec4 comp;
    float gComp;

    int loopStart = Reverse ? 1 : int(floor(Wildness));
    int loopEnd = Reverse ? int(floor(Wildness)) : 0;
    int loopStep = Reverse ? 1 : -1;

    for (int i = loopStart; Reverse ? (i <= loopEnd) : (i > loopEnd); i += loopStep) {
      comp = IMG_NORM_PIXEL(feedbackImage, st + i * dir);
      gComp = gscale(comp.rgb);

      if (dir.x < 0.0) {
        if (gCurr > Threshold && comp.a > 0.01 && (Reverse ? gComp < gCurr : gComp > gCurr)) {
          gl_FragColor = comp;
          return;
        }
      } else {
        if (gComp > Threshold && comp.a > 0.01 && (Reverse ? gCurr <= gComp : gCurr >= gComp)) {
          gl_FragColor = comp;
          return;
        }
      }
    }
    gl_FragColor = curr;
  }

}