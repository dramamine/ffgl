/*{
  "DESCRIPTION": "Wild Pixel Sort",
  "CREDIT": "Your Name",
  "ISFVSN": "2",
  "CATEGORIES": ["Glitch", "Stylize"],
  "INPUTS": [
    {
      "NAME": "inputImage",
      "TYPE": "image"
    },
    {
      "NAME": "Wildness",
      "TYPE": "float",
      "MIN": 0.0,
      "MAX": 100.0,
      "DEFAULT": 10.0
    },
    {
      "NAME": "Threshold",
      "TYPE": "float",
      "MIN": 0.0,
      "MAX": 1.0,
      "DEFAULT": 0.5
    },
    {
      "NAME": "Vertical",
      "TYPE": "bool",
      "DEFAULT": false
    }
  ],
  "PASSES": [
    {
      "TARGET": "OldTexture",
      "PERSISTENT": true
    }
  ]
}*/

// grayscale average of the colors
float gscale (vec3 c) { return (c.r+c.g+c.b)/3.; }

void main()
{
  vec2 st = isf_FragNormCoord;
  vec4 color = IMG_NORM_PIXEL(OldTexture, st);

  gl_FragColor = color;
  if (Wildness < 1.) {
    gl_FragColor = IMG_NORM_PIXEL(inputImage, st);
  }

  // the frame number parity, -1 is odd 1 is even
  float fParity = mod(float(FRAMEINDEX), 2.) * 2. - 1.;

  if (Vertical) {
    // we differentiate every 1/2 pixel on the horizontal axis, will be -1 or 1
    float vp = mod(floor(isf_FragNormCoord.y * RENDERSIZE.y), 2.0) * 2. - 1.;

    vec2 dir = vec2(0, 1);
    dir*= fParity * vp;
    dir/= RENDERSIZE.xy;

    // we sort
    vec4 curr = IMG_NORM_PIXEL(inputImage, st);

    float gCurr = gscale(curr.rgb);

    // we prevent the sort from happening on the borders
    if (st.y + dir.y < 0.0 || st.y + dir.y > 1.0) {
      gl_FragColor = curr;
      return;
    }

    vec4 comp;
    float gComp;

    for (int i = int(floor(Wildness)); i > 0; i--) {
      comp = IMG_NORM_PIXEL(inputImage, st + i * dir);
      gComp = gscale(comp.rgb);
      if (dir.y < 0.0) {
        if (gCurr > Threshold && gComp > gCurr) { // (gCurr > Threshold &&
          gl_FragColor = comp;
          return;
        }
      } else {
        if (gComp > Threshold && gCurr >= gComp) {
          gl_FragColor = comp;
          return;
        }
      }
    }
    gl_FragColor = curr;
  } else {

    // we differentiate every 1/2 pixel on the horizontal axis, will be -1 or 1
    float vp = mod(floor(isf_FragNormCoord.x * RENDERSIZE.x), 2.0) * 2. - 1.;

    vec2 dir = vec2(1, 0);
    dir*= fParity * vp;
    dir/= RENDERSIZE.xy;

    // we sort
    vec4 curr = IMG_NORM_PIXEL(inputImage, st);

    float gCurr = gscale(curr.rgb);

    // we prevent the sort from happening on the borders
    if (st.x + dir.x < 0.0 || st.x + dir.x > 1.0) {
      gl_FragColor = curr;
      return;
    }

    vec4 comp;
    float gComp;

    for (int i = int(floor(Wildness)); i > 0; i--) {
      comp = IMG_NORM_PIXEL(inputImage, st + i * dir);
      gComp = gscale(comp.rgb);

      if (dir.x < 0.0) {
        if (gCurr > Threshold && gComp > gCurr) {
          gl_FragColor = comp;
          return;
        }
      } else {
        if (gComp > Threshold && gCurr >= gComp) {
          gl_FragColor = comp;
          return;
        }
      }
    }
    gl_FragColor = curr;
  }

}