/*{
  "DESCRIPTION": "Pixelsort XTC",
  "CREDIT": "domegod",
  "ISFVSN": "2",
  "CATEGORIES": ["Glitch", "Stylize"],
  "INPUTS": [
    {
      "NAME": "inputImage",
      "TYPE": "image"
    },
    {
      "NAME": "feedbackImage",
      "TYPE": "image"
    },
    {
      "NAME": "noiseImage",
      "TYPE": "image"
    },
    {
      "NAME": "Threshold",
      "TYPE": "float",
      "MIN": 0.0,
      "MAX": 1.0,
      "DEFAULT": 0.5
    },
    {
      "NAME": "Distance",
      "TYPE": "float",
      "MIN": 0.0,
      "MAX": 10.0,
      "DEFAULT": 1.0
    },
    {
      "NAME": "Freshness",
      "TYPE": "float",
      "MIN": 0.0,
      "MAX": 1.0,
      "DEFAULT": 0.5
    },
    {
      "NAME": "On",
      "TYPE": "bool",
      "DEFAULT": true
    },
    {
      "NAME": "Vertical",
      "TYPE": "bool",
      "DEFAULT": false
    },
    {
      "NAME": "Reverse",
      "TYPE": "bool",
      "DEFAULT": false
    }
  ],
    "PASSES": [
    {
      "TARGET": "OldTexture",
      "PERSISTENT": true
    }
  ]
}*/

// grayscale average of the colors
float gscale (vec3 c) { return (c.r+c.g+c.b)/3.; }

// Check if adjacent pixels are sorted
bool isSorted(vec2 st, vec2 dir, bool reverse) {
  vec4 left = IMG_NORM_PIXEL(feedbackImage, st - dir);
  vec4 right = IMG_NORM_PIXEL(feedbackImage, st + dir);
  float gLeft = gscale(left.rgb);
  float gRight = gscale(right.rgb);

  // Skip check if either pixel is transparent
  if (left.a < 0.01 || right.a < 0.01) return false;

  if (reverse) {
    return gLeft >= gRight; // Sorted if left is brighter
  } else {
    return gLeft <= gRight; // Sorted if left is darker
  }
}

void main()
{
  vec2 st = isf_FragNormCoord;

  if (!On) {
    gl_FragColor = IMG_NORM_PIXEL(inputImage, st);
    return;
  }
  int d = int(Distance);
  if (d == 0) {
    gl_FragColor = IMG_NORM_PIXEL(feedbackImage, st);
    return;
  }

  // the frame number parity, -1 is odd 1 is even
  float fParity = mod(float(FRAMEINDEX), 2.) * 2. - 1.;

  if (Vertical) {
    // we differentiate every 1/2 pixel on the vertical axis, will be -1 or 1
    float vp = mod(floor(isf_FragNormCoord.y * RENDERSIZE.y), 2.0) * 2. - 1.;

    vec2 dir = vec2(0, 1);
    if (Reverse) dir *= -1.0;
    dir*= fParity * vp;
    dir/= RENDERSIZE.xy;

    // we sort
    vec4 curr = IMG_NORM_PIXEL(feedbackImage, st);

    float gCurr = gscale(curr.rgb);

    // skip transparent pixels
    if (curr.a < 0.01) {
      gl_FragColor = curr;
      return;
    }

    // we prevent the sort from happening on the borders
    if (st.y + dir.y < 0.0 || st.y + dir.y > 1.0) {
      gl_FragColor = curr;
      return;
    }

    vec4 comp;
    float gComp;

    // Check pixel at d away
    comp = IMG_NORM_PIXEL(feedbackImage, st + (d * 2 - 1) * dir);
    gComp = gscale(comp.rgb);
    if (dir.y < 0.0) {
      if (gCurr > Threshold && comp.a > 0.01 && (Reverse ? gComp < gCurr : gComp > gCurr)) {
        gl_FragColor = comp;
        return;
      }
    } else {
      if (gComp > Threshold && comp.a > 0.01 && (Reverse ? gCurr <= gComp : gCurr >= gComp)) {
        gl_FragColor = comp;
        return;
      }
    }
    // Noise-based freshness decision
    vec4 noise = IMG_NORM_PIXEL(noiseImage, st);
    float noiseVal = gscale(noise.rgb);
    if (noiseVal < Freshness) {
      gl_FragColor = IMG_NORM_PIXEL(inputImage, st);
    } else {
      gl_FragColor = IMG_NORM_PIXEL(feedbackImage, st);
    }
  } else {

    // we differentiate every 1/2 pixel on the horizontal axis, will be -1 or 1
    float vp = mod(floor(isf_FragNormCoord.x * RENDERSIZE.x), 2.0) * 2. - 1.;

    vec2 dir = vec2(1, 0);
    if (Reverse) dir *= -1.0;
    dir*= fParity * vp;
    dir/= RENDERSIZE.xy;

    // we sort
    vec4 curr = IMG_NORM_PIXEL(feedbackImage, st);
    float gCurr = gscale(curr.rgb);

    // skip transparent pixels
    if (curr.a < 0.01) {
      gl_FragColor = curr;
      return;
    }

    // we prevent the sort from happening on the borders
    if (st.x + dir.x < 0.0 || st.x + dir.x > 1.0) {
      gl_FragColor = curr;
      return;
    }

    vec4 comp;
    float gComp;

    // Check pixel at d away
    comp = IMG_NORM_PIXEL(feedbackImage, st + (d * 2 - 1) * dir);
    gComp = gscale(comp.rgb);

    if (dir.x < 0.0) {
      if (gCurr > Threshold && comp.a > 0.01 && (Reverse ? gComp < gCurr : gComp > gCurr)) {
        gl_FragColor = comp;
        return;
      }
    } else {
      if (gComp > Threshold && comp.a > 0.01 && (Reverse ? gCurr <= gComp : gCurr >= gComp)) {
        gl_FragColor = comp;
        return;
      }
    }
    // Noise-based freshness decision
    vec4 noise = IMG_NORM_PIXEL(noiseImage, st);
    float noiseVal = gscale(noise.rgb);
    if (noiseVal < Freshness) {
      gl_FragColor = IMG_NORM_PIXEL(inputImage, st);
    } else {
      gl_FragColor = IMG_NORM_PIXEL(feedbackImage, st);
    }
  }

}